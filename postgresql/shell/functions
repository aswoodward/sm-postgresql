#!/bin/sh

typeset -ga configure_flags >/dev/null 2>&1 # Don't care if declared already.

postgresql_initialize()
{
  trace_filter postgresql || set -o xtrace

  PATH="${sm_path}/bin:${sm_path}/pkg/active/bin:${sm_path}/pkg/active/sbin:$PATH"
  export PATH

  true \
    ${service_port:=5432} \
    ${service_bind_interface:="127.0.0.1"}

  service initialize

  config read file defaults from postgresql version key version prefix package

  service_binary="${service_bin_path}/pg_ctl"
  service_cli_binary="${service_bin_path}/psql"

  if user is root
  then
    if os is darwin
    then
      service_user="_postgres"
    else
      service_user="postgres"
    fi
  else
    service_user="$USER"
  fi
  package_user="${service_user}"

  local _action

  service_data_path="${service_db_path}/${package_version}/data"
  if array is empty service_flags
  then
    _action="${action//\(*}"
    service_flags+=(${_action//*_} -D "$service_data_path" -s )
    service_stop_flags+=( -m fast -w )
  fi

  typeset -gx PGDATA
  PGDATA="${service_data_path}"

  service_pid_file="/var/run/postgresql/postgresql.pid"
}

postgresql_prefetch()
{
  package define \
    base_url "http://ftp9.us.postgresql.org/pub/mirrors/postgresql/source/v${package_version}"
}

postgresql_database_setup()
{
  local _file _command _initdb_flags

  path create "${service_data_path}"

  if [[ ${service_user} == "postgresql" ]]
  then service_user="postgres" ; fi

  path chown "$service_user:$service_user" recursively "${service_data_path}"

  if ! path exists "${service_data_path}"
  then
    log "Initializing postgresql data directory in $service_data_path"

    _initdb_flags=(
    --pgdata="'${service_data_path}'"
    --encoding=utf8
    --locale=C
    --username=$service_user
    )

    path create "${service_data_path}" owner "${service_user}"

    _command="$install_path/bin/initdb ${_initdb_flags[*]}"

    if user is root
    then
      if ! su - "${service_user}" -c "${_command}"
      then
        __sm.log.warn "initdb failed, command:\n${_command}"
      fi
    else
      if ! "${_command}"
      then
        __sm.log.warn "initdb failed, command:\n${_command}"
      fi
    fi
  fi

  path chown "$service_user:$service_user" recursively "${service_data_path}"
  path chmod 0700 recursively "${service_data_path}"
}

postgresql_service_setup()
{
  local file _entries
  log "Configuring postgresql server."

  paths create "${service_data_path}" "${log_path}"

  postgresql_database_setup

  log "service_data_path: ${service_data_path}"
  for file in postgresql pg_hba pg_ident recovery
  do
    if file is missing "${service_data_path}/${file}.conf"
    then
      if file is missing "${service_data_path}/${file}.conf.sample"
      then
        log "Missing ${service_data_path}/${file}.conf.sample, skipping."
        continue
      fi
      log "Installing ${file}.conf to ${service_data_path}/"

      files copy force \
        from "$service_data_path/${file}.conf.sample" \
        to "$service_data_path/${file}.conf"
    fi
  done

  path chown "$service_user:$service_user" recursively "${service_data_path}"
}

postgresql_preconfigure()
{
  if [[ "$action" = *install ]]
  then
    configure_flags=(
      --prefix="${install_base_path}/${package_version}"
      --datadir="${install_base_path}/${package_version}/data"
      --with-openssl
      --enable-shared
    )
    export CFLAGS='-O2'
  fi
}


postgresql_uninstall() {
  paths remove \
    "${prefix_path}/${package_name}" \
    "${prefix_path}/${package_name}-${package_version}"

  remove_files \
    /etc/profile.d/postgresql.sh \
    /etc/ld.so.conf.d/postgresql.conf \
    "${init_scripts_path}/postgresql"

  user delete "${package_user}"

  log "Removal of ${package_name} complete."
}

